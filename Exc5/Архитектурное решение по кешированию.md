Имеет смысл кэшировать следующие части системы: 
- MES API получение списка активных заказов для операторов
- MES API, расчет стоимости типовых изделий с одинаковыми параметрами
- справочные данные, например, список статусов заказа, фильтры

### Мотивация
- Снижение нагрузки на базу за счет уменьшения кол-ва запросов к базе
- Улучшение скорости интерфейсов операторов
- Устранение узких мест в производительности за счет кэширования списка заказов результатов расчета стоимости типовых изделий

### Предлагаемое решение
Рассмотрим кэширование для списка заказов.
Для списка заказов будем использовать серверное кэширование, так как:
- Заказы достаточно часто обновляются,а клиенту нужно работать с актуальными данными.
- В серверном кэшировании проще настроить инвалидацию, например при изменении статуса заказа.
- Список заказов для операторов один и тот же, нет смысла его дублировать на каждом клиенте.

Для справочных данных можно использовать клиентское кэширование, так как эти данные изменяются достаточно редко и можно не создавать лишнюю нагрузку на сервер.

#### Анализ паттернов кэширования
Был выбран комбинированный паттерн `Write-Through` + `Read-Through`. 
Объединение этих двух стратегий позволяет обеспечить актуальность данных в кэше и ускорить доступ к ним при последующих чтениях.

Почему был выбран `Write-Through`?
- Так как заказы изменяются достаточно часто (например, меняется статус заказа или добавляется новый заказ), то важно актуализировать данные в кэше.
- Позволяет точечно обновлять данные в кэше по конкретным заказам.
Почему не был выбран `Write Behind`?
- Риски неконсистентности данных в кэше и в БД.
- Много данных для синхронизации с БД могут накопиться и при сбое кэша они будут утеряны
- Требует сложной логики восстановления в случае сбоев.
Почему не был выбран `Refresh Ahead`?
- В данном случае он будет избыточен, так как на каждое обновление мы и так записываем значение сначала кэш, а потом в БД. Это значит что в большинстве случаев данные в кэше будут актуальны.
- Нет стабильного паттерна доступа, по которому можно обновлять значения в кэше.

Почему был выбран `Read-Through` для оптимизации чтения? (Стоит отметить, что в качестве альтернативы здесь можно было бы использовать и `Cache Aside`)
- Гарантирует быстрое получение данных и их актуальность.
- Приложению не нужно заботиться о том, где находятся данные — в кэше или базе.
- Read-Through избавляет приложение от необходимости обрабатывать промахи.
- Работает эффективно в сочетании с `Write-Through`.

#### Диаграмма последовательности действий
[sequence_diagram.puml](sequence_diagram.puml)

Операция записи (Write-Through):
1. User → MES: Пользователь создаёт или обновляет заказ в приложении.
2. MES → Cache: Приложение записывает данные заказа в кэш.
3. Cache → Cache: кэш обновляет данные.
4. Cache → DB: Приложение записывает данные заказа в базу данных.

Операция чтения (Read-Through):
1. User → MES: Пользователь запрашивает список заказов.
2. MES → Cache: Приложение проверяет кэш на наличие данных.
3. Cache → DB: При Cache Miss кэш запрашивает данные из базы данных.
4. Cache → MES: кэш возвращает данные приложению, которое передаёт их пользователю.


#### Инвалидация кэша, сравнительный анализ
| **Стратегия инвалидации**       | **Плюсы**                                                                                 | **Минусы**                                                                                               | **Оценка для нашей задачи**                                                                          |
|---------------------------------|------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------|
| **Временная инвалидация**       | - Простая реализация<br>- Подходит для данных с предсказуемым сроком устаревания          | - Данные могут быть устаревшими до момента автоматической очистки<br>- Не подходит для частых изменений  | **Низкая**. Неприемлемо для списка заказов, где важна актуальность.                                  |
| **Инвалидация на основе изменений** | - Гранулярность: обновляются только изменившиеся данные<br>- Обеспечивает актуальность кэша | - Требует триггеров или событий на уровне изменений<br>- Сложнее реализовать в распределённых системах   | **Высокая**. Лучшая стратегия для обеспечения актуальности данных. Хорошо сочетается с Write-Through |
| **Программная инвалидация**     | - Гибкость: можно очистить или обновить любые данные<br>- Контроль над процессом          | - Высокая сложность управления<br>- Ошибки в реализации могут привести к устареванию данных              | **Средняя**. Требует больших усилий на управление и автоматизацию.                                   |
| **Инвалидация по ключу**        | - Гибкость для точечных обновлений<br>- Хорошо работает в сценариях с уникальными ключами | - Трудно масштабировать при работе с группами данных, такими как списки<br>- Возможны ошибки синхронизации | **Средняя**. Используется для индивидуальных заказов, но сложно для списков.                         |

**Инвалидация на основе изменений** — наиболее подходящая стратегия для нашей задачи, поскольку она:
* Обеспечивает актуальность данных для операторов, минимизируя устаревание кэша.
* Поддерживает гранулярное обновление данных, не затрагивая весь список заказов.
* Снижает нагрузку на базу данных, работая только с изменившимися заказами.



